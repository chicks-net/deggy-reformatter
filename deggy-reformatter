#!/usr/bin/perl

use strict;
use warnings;
use Carp;
use Data::Dumper;
use DateTime;

my ($filename) = @ARGV;
croak "no $filename" unless -f $filename;

my $text = `unrtf --text '$filename' | grep -v '^###'`;
print "got " . length($text) . " characters\n";

my @raw_lines = split( /\n/x, $text );

my @ingested_lines = ingest(@raw_lines);

sub ingest {
	my (@lines) = @_;
	my @newlines;
	my $continue_flag;
	foreach my $line (@lines) {
		next if $line =~ /^Printed[ ]on/x;
		next if $line =~ /^Range/x;
		next if $line =~ /^DOWNLOAD[ ]REPORT/x;
		next if $line =~ /^by[ ]touch/x;
		next if $line =~ /^Deggy[ ]Corp/x;
		next if $line =~ /^Touch[ ]date/x;
		next if $line =~ /^Description/x;
		next if $line =~ /^\d+[ ]of[ ]\d+/x;
		next if $line =~ /^[- ]*$/x;
		next if $line =~ m{^\d+/\d+/\d+[ ]-[ ]\d+/\d+/\d+}x;

		if ( $line =~ /^Pen[ ]download/x ) {
			$continue_flag = 1;
			push( @newlines, $line );
		} elsif ($continue_flag) {
			$newlines[ scalar(@newlines) - 1 ] .= $line;
			$continue_flag--;
		} elsif ( $line =~ /[AP]M[ ]*$/x ) {
			if ( $line =~ /[ ]*$/x ) {
				$continue_flag = 1;
			} else {
				$continue_flag = 0;
			}

			if ( $line =~ /AM[ ]*$/x ) {
				if ( $line =~ /(\d+):(\d+):(\d+)[ ]AM/x ) {
					my ( $h, $m, $s ) = ( $1, $2, $3 );
					$h = 0 if $h == 12;
					my $newtime = sprintf( "       %02u:%02u:%02u", $h, $m, $s );
					$line =~ s/(\d+):(\d+):(\d+)[ ]AM/$newtime/x;
				} else {
					croak "bad format in $line";
				}
			}

			if ( $line =~ /PM[ ]*$/x ) {
				if ( $line =~ /(\d+):(\d+):(\d+)[ ]PM/x ) {
					my ( $h, $m, $s ) = ( $1, $2, $3 );
					$h += 12 unless $h == 12;
					my $newtime = sprintf( "       %02u:%02u:%02u", $h, $m, $s );
					$line =~ s/(\d+):(\d+):(\d+)[ ]PM/$newtime/x;
				} else {
					croak "bad format in $line";
				}
			}

			push( @newlines, $line );
		} elsif ( $line =~ /^Customer.Site/x ) {
			$continue_flag = 1;
			push( @newlines, $line );
		} elsif ( $line =~ /^Number[ ]of[ ]/x ) {
			$continue_flag = 1;
			push( @newlines, $line );
		} else {
			push( @newlines, $line );
		}
	}
	return @newlines;
}

print "\n\n----------------------begin-redone-----------------\n";
my $started = 0;
my $started_at;
my $hits = [];
my %hour_done;

foreach my $line (@ingested_lines) {
	if ( $line =~ /Start/ ) {
		if ($started) {
			validations($line);
		}
		$started    = 1;
		$hits       = [];
		$started_at = $line;
		$started_at =~ s/\s+Check.*$//x;

		print "\n";
	}

	print "$line\n";

	if ( $line =~ /Check[ ]Point[ ](\d+)/x ) {
		push( @$hits, $1 );
	}
}
validations();
post_validations();

sub validations {
	my ($next_line) = @_;
	my $need_hits   = [ 1 .. 7 ];
	my $fuzz        = 5;
	my $missing     = [];

	# look for missing points
	NEED: foreach my $need (@$need_hits) {
		foreach my $hit (@$hits) {
			next NEED if $hit == $need;
		}
		push( @$missing, $need );
	}
	my $hit_count = scalar(@$hits);

	# how long since previous line?
	my $next_start = $next_line;
	$next_start =~ s/\s+Check.*$//x;
	my $prev_date     = parseDate($started_at);
	my $start_seconds = 0;
	if ( length $next_start ) {
		my $next_date = parseDate($next_start);
		my $duration  = $next_date->subtract_datetime_absolute($prev_date);
		$start_seconds = $duration->in_units('seconds');
	}

	# is it a double start?
	if ( $hit_count == 1 and $next_line =~ /Start/ ) {
		unless ( abs($start_seconds) < $fuzz ) {
			print
			  "# double start $started_at within ${start_seconds}s of next start, only allowed ${fuzz}s\n";
		}

		return;    # skip rest of checks since they will confuse folks
	}

	# basic swipe match check
	if ( scalar @$missing ) {
		print "# $started_at ISSUE: had $hit_count swipes, missing point " . join( ",", @$missing ) . "\n";
	} elsif ( $hit_count > scalar @$need_hits ) {
		print "# $started_at ISSUE: extra swipe ($hit_count total)\n";
	}

	# did it start at the right time?
	if ( $started_at =~ m{^(\d+)/(\d+)/(\d+)\s+(\d+):(\d+):(\d+)}x ) {
		my ( $month, $day, $year, $hour, $minute, undef ) = ( $1, $2, $3, $4, $5, $6 );
		unless ( $minute > 0 and $minute < 30 ) {    ## no critic (ProhibitNegativeExpressions)
			print "# $started_at ISSUE: starts at bad minute ($minute)\n";
		}
	} else {
		croak "bad format in '$started_at'";
	}

	# TODO: don't skip any hours
	my $ok_interval = 3600 * 1.6;
	unless ( $start_seconds < $ok_interval ) {
		my $hours = sprintf( "%.2fh", $start_seconds / 3600 );
		print "# $hours elapses before next run\n";
	}

	# always do Fri 1800 - Sat 0600 and Sat 1500 - Sun 1900
	my $this_date = parseDate($started_at);
	my $dow       = $this_date->day_of_week;
	if ( $dow >= 5 ) {    # Friday-Sunday
		my $this_hour = $this_date->hour();
		$hour_done{$dow}->{$this_hour}++;
	}

	# core hours validation completed in post_validations()

	# all good
	return 0;
}

sub post_validations {

	# always do Fri 1800 - Sat 0600 and Sat 1500 - Sun 1900
	my $must_dos = {
		5 => [ 18 .. 23 ],
		6 => [ 0 .. 6, 15 .. 23 ],
		7 => [ 0 .. 19 ],
	};
	my $day_decode = {
		5 => 'Fri',
		6 => 'Sat',
		7 => 'Sun',
	};

	foreach my $day ( sort keys %$must_dos ) {
		my $humanday = $day_decode->{$day};

		foreach my $hour ( @{ $must_dos->{$day} } ) {
			unless ( $hour_done{$day}->{$hour} ) {
				printf( "## ISSUE: skipped core hour $humanday %02i00\n", $hour );
			}
		}
	}

	# all good
	return 0;
}

sub parseDate {
	my ($deggy_date_string) = @_;
	my ( $month, $day, $year, $hour, $minute, $second );

	if ( $deggy_date_string =~ m{^(\d+)/(\d+)/(\d+)\s+(\d+):(\d+):(\d+)}x ) {
		( $month, $day, $year, $hour, $minute, $second ) = ( $1, $2, $3, $4, $5, $6 );
	} else {
		croak "bad format in '$deggy_date_string'";
	}

	my $date_object = DateTime->new(
		year      => $year,
		month     => $month,
		day       => $day,
		hour      => $hour,
		minute    => $minute,
		second    => $second,
		time_zone => 'America/New_York',
	);
	croak "did not get an object" unless ref $date_object;

	return $date_object;
}
