#!/usr/bin/perl

use strict;
use warnings;
use Carp;
use Data::Dumper;
use DateTime;

my ($filename) = @ARGV;
croak "no $filename" unless -f $filename;

my $text = `unrtf --text '$filename' | grep -v '^###'`;
print "got " . length($text) . " characters\n";

my @raw_lines = split( /\n/x, $text );

my @ingested_lines = ingest(@raw_lines);

sub ingest {
	my (@lines) = @_;
	my @newlines;
	my $continue_flag;
	foreach my $line (@lines) {
		next if $line =~ /^Printed[ ]on/x;
		next if $line =~ /^Range/x;
		next if $line =~ /^DOWNLOAD[ ]REPORT/x;
		next if $line =~ /^by[ ]touch/x;
		next if $line =~ /^Deggy[ ]Corp/x;
		next if $line =~ /^Touch[ ]date/x;
		next if $line =~ /^Description/x;
		next if $line =~ /^\d+[ ]of[ ]\d+/x;
		next if $line =~ /^[- ]*$/x;
		next if $line =~ m{^\d+/\d+/\d+[ ]-[ ]\d+/\d+/\d+}x;

		if ( $line =~ /^Pen[ ]download/x ) {
			$continue_flag = 1;
			push( @newlines, $line );
		} elsif ($continue_flag) {
			$newlines[ scalar(@newlines) - 1 ] .= $line;
			$continue_flag--;
		} elsif ( $line =~ /[AP]M[ ]*$/x ) {
			if ( $line =~ /[ ]*$/x ) {
				$continue_flag = 1;
			} else {
				$continue_flag = 0;
			}

			if ( $line =~ /AM[ ]*$/x ) {
				if ( $line =~ /(\d+):(\d+):(\d+)[ ]AM/x ) {
					my ( $h, $m, $s ) = ( $1, $2, $3 );
					$h = 0 if $h == 12;
					my $newtime = sprintf( "       %02u:%02u:%02u", $h, $m, $s );
					$line =~ s/(\d+):(\d+):(\d+)[ ]AM/$newtime/x;
				} else {
					croak "bad format in $line";
				}
			}

			if ( $line =~ /PM[ ]*$/x ) {
				if ( $line =~ /(\d+):(\d+):(\d+)[ ]PM/x ) {
					my ( $h, $m, $s ) = ( $1, $2, $3 );
					$h += 12 unless $h == 12;
					my $newtime = sprintf( "       %02u:%02u:%02u", $h, $m, $s );
					$line =~ s/(\d+):(\d+):(\d+)[ ]PM/$newtime/x;
				} else {
					croak "bad format in $line";
				}
			}

			push( @newlines, $line );
		} elsif ( $line =~ /^Customer.Site/x ) {
			$continue_flag = 1;
			push( @newlines, $line );
		} elsif ( $line =~ /^Number[ ]of[ ]/x ) {
			$continue_flag = 1;
			push( @newlines, $line );
		} else {
			push( @newlines, $line );
		}
	}
	return @newlines;
}

print "\n\n------------------------------------------- begin redone --------------------------------------\n";
my $started = 0;	# are we inside of one Deggy rounds
my $started_at;		# when did this round start?
my $hits = [];		# currend rounds hits
my $timeline = [];	# GLOBAL timeline of event hashes
my %hour_done;
my $first_day;		# the earliest timed event spotted
my $prev_end_date;	# the time for the last scan of the previous run for validations()

foreach my $line (@ingested_lines) {
	my($day_of_week, $line_date);
	my $blank_before = 0;

	if ( $line =~ /Check Point/) {
		my $tmp_line = $line;
		$tmp_line =~ s/\s+Check.*$//x;
		$line_date = $tmp_line;
	}

	if ( $line =~ /Start/ ) {
		if ($started) {
			validations($line);
		}
		$started    = 1;
		$hits       = [];
		$started_at = $line_date;
		$blank_before = 1;
	}

	# if it has a date, add it to the timeline
	if (defined $line_date) {
		my $date_object     = parseDate($line_date);
		$day_of_week = $date_object->day_name();

		# track earliest when
		$first_day = $date_object unless defined $first_day;
		if ( DateTime->compare( $first_day, $date_object) > 0 ) {
			$first_day = $date_object;
		}

		$prev_end_date = $date_object->clone;
		
		# pull out the parts that aren't date or time related
		my $content_line = $line;
		$content_line =~ s/^.*(Check)/$1/;

		push(@$timeline, {
			when => $date_object,
			day_of_week => $day_of_week,
			whole_line => $line,
			content_line => $content_line,
			line_date => $line_date,
			blank_before => $blank_before,
			mark_issue => 0,
		});
	} else {
		print "$line\n";
	}

	if ( $line =~ /Check[ ]Point[ ](\d+)/x ) {
		push( @$hits, $1 );
	}
}

validations();
post_validations();
add_schedule();
sort_timeline();

print "\n";

foreach my $entry (@$timeline) {
	my $when = $entry->{when};		# DateTime handle
	my $day_of_week = $entry->{day_of_week}; # Wednesday
	my $line_date = $entry->{line_date};
	my $whole_line = $entry->{whole_line};
	my $content_line = $entry->{content_line};
	my $blank_before = $entry->{blank_before} || 0;	# should it get a blank line before it
	my $mark_issue = $entry->{mark_issue};	# is it an issue and the line should start with the # symbol
	$mark_issue = 1 unless defined $mark_issue;

	if ($mark_issue) {
		$day_of_week = sprintf("# %8s",$day_of_week);
	} else {
		$day_of_week = sprintf("%10s",$day_of_week);
	}

	print "\n" if $blank_before;
	print "$day_of_week $line_date       $content_line\n";
}

# checks for each Deggy run
sub validations {
	my ($next_line) = @_;
	my $need_hits   = [ 1 .. 7 ];
	my $fuzz        = 5;
	my $missing     = [];

	# look for missing points
	NEED: foreach my $need (@$need_hits) {
		foreach my $hit (@$hits) {
			next NEED if $hit == $need;
		}
		push( @$missing, $need );
	}
	my $hit_count = scalar(@$hits);

	# always do Fri 1800 - Sat 0600 and Sat 1500 - Sun 1900
	# core hours validation completed in post_validations()
	my $this_date = parseDate($started_at);
	my $dow       = $this_date->day_of_week;
	if ( $dow >= 5 ) {    # Friday-Sunday
		my $this_hour = $this_date->hour();
		$hour_done{$dow}->{$this_hour}++;
	}

	# how long since previous line?
	my $next_start = $next_line || '';
	$next_start =~ s/\s+Check.*$//x;
	my $prev_start_date     = parseDate($started_at);
	$started_at = $prev_start_date->day_name() . ' ' . $started_at;
	my $start_seconds = 0;
	if ( length $next_start ) {
		my $next_date = parseDate($next_start);
		my $duration  = $next_date->subtract_datetime_absolute($prev_start_date);
		$start_seconds = $duration->in_units('seconds');
	} else {
		return;
	}

	# is it a double start?
	if ( $hit_count == 1 and $next_line =~ /Start/ ) {
		unless ( abs($start_seconds) < $fuzz ) {
			my $start_minutes = sprintf("%.1f",$start_seconds/60);
			my $content_line = "WARN: double start within ${start_minutes} minutes of next start, only allowed ${fuzz}s";
			push (@$timeline,{
				when => $prev_start_date->clone(),
				content_line => $content_line,
				mark_issue => 1,
			});
		}

		return;    # skip rest of checks since they will confuse folks
	}

	# basic swipe match check
	if ( scalar @$missing ) {
		my $content_line = "ISSUE: had $hit_count swipes, missing point " . join( ",", @$missing );
		push (@$timeline,{
			when => $prev_end_date->clone(),
			content_line => $content_line,
			mark_issue => 1,
		});
	} elsif ( $hit_count > scalar @$need_hits ) {
		my $content_line = "ISSUE: extra swipe ($hit_count total)";
		push (@$timeline,{
			when => $prev_end_date->clone(),
			content_line => $content_line,
			mark_issue => 1,
		});
	}

	# did it start at the right time?
	if ( $started_at =~ m{^(\w+\s+)?(\d+)/(\d+)/(\d+)\s+(\d+):(\d+):(\d+)}x ) {
		my ( undef, $month, $day, $year, $hour, $minute, undef ) = ( $1, $2, $3, $4, $5, $6, $7 );
		unless ( $minute > 0 and $minute < 30 ) {    ## no critic (ProhibitNegativeExpressions)
			my $content_line = "WARN: starts at bad minute ($minute)";
			push (@$timeline,{
				when => $prev_start_date->clone(),
				content_line => $content_line,
				mark_issue => 1,
			});
		}
	} else {
		croak "bad format in '$started_at'";
	}

	# show skipped hours
	my $ok_interval = 3600 * 1.6;
	unless ( $start_seconds < $ok_interval ) {
		my $hours = sprintf( "%.2fh", $start_seconds / 3600 );
		my $content_line = "NOTE: $hours elapses before next run";
		push (@$timeline,{
			when => $prev_end_date->clone(),
			content_line => $content_line,
			mark_issue => 1,
		});
	}

	# all good
	return 0;
}

sub post_validations {
	my $day_decode;		# hashref: day number to name
	my $date_cursor = $first_day->clone();
	for (1..7) {
		my $day_name = $date_cursor->day_name();
		my $day_of_week = $date_cursor->day_of_week();
		$day_decode->{$day_of_week} = {
			human_day => $day_name,
			date_object => $date_cursor->clone(),
		};
		$date_cursor->add( days => 1 );
	}

	# always do Fri 1800 - Sat 0600 and Sat 1500 - Sun 1900
	my $must_dos = {
		5 => [ 18 .. 23 ],
		6 => [ 0 .. 6, 15 .. 23 ],
		7 => [ 0 .. 19 ],
	};

	foreach my $day ( sort keys %$must_dos ) {
		my $humanday = $day_decode->{$day}->{human_day};

		foreach my $hour ( @{ $must_dos->{$day} } ) {
			unless ( $hour_done{$day}->{$hour} ) {
				my $date_object = $day_decode->{$day}->{date_object}->clone();
				$date_object->set( minute => 0, hour => $hour, second => 0 );
				my $content_line = sprintf( "ISSUE: skipped core hour $humanday %02i00", $hour );
				push (@$timeline,{
					when => $date_object,
					content_line => $content_line,
					blank_before => 1,
					mark_issue => 1,
				});
			}
		}
	}

	# all good
	return 0;
}

sub sort_timeline {
	# quietly fill in gaps in data
	foreach my $entry (@$timeline) {
		my $when = $entry->{when};		# DateTime handle

		unless (defined $entry->{day_of_week} ) {
			$entry->{day_of_week} = $when->day_name;
		}

		unless (defined $entry->{line_date} ) {
			#$entry->{line_date} = $when->strftime("%m/%d/%Y      %H:%M:%S");
			$entry->{line_date} = $when->format_cldr("M/d/yyyy        HH:mm:ss");
		}
	}
	
	# actually do sorting
	my @tmp_timeline = sort { DateTime->compare( $a->{when}, $b->{when} ) } @$timeline;
	$timeline = \@tmp_timeline;
}

sub parseDate {
	my ($deggy_date_string) = @_;
	my ( $month, $day, $year, $hour, $minute, $second );

#warn "parseDate $deggy_date_string";
	if ( $deggy_date_string =~ m{^(\w+\s+)?(\d+)/(\d+)/(\d+)\s+(\d+):(\d+):(\d+)}x ) {
		( undef, $month, $day, $year, $hour, $minute, $second ) = ( $1, $2, $3, $4, $5, $6, $7 );
	} else {
		croak "bad format in '$deggy_date_string'";
	}

	my $date_object = DateTime->new(
		year      => $year,
		month     => $month,
		day       => $day,
		hour      => $hour,
		minute    => $minute,
		second    => $second,
		time_zone => 'Etc/UTC',
	);
	croak "did not get an object" unless ref $date_object;

	return $date_object;
}

sub add_schedule {

	#print "add_schedule:$first_day\n";

	# make day of week decoder ring
	my $decoder_cursor = $first_day->clone();
	my @days_of_weeks;
	for (1..7) {
		my $day_name = $decoder_cursor->day_name();
		push(@days_of_weeks,$day_name);
		$decoder_cursor->add( days => 1 );
	}
	push(@days_of_weeks,@days_of_weeks); # next week

	# read schedule.txt
	my $schedule_filename = 'schedule.txt';

	my ($worked_schedule);
	if (-e $schedule_filename) {
		my $schedule_fh;
		open($schedule_fh,'<',$schedule_filename) or die "failed to open schedule file '$schedule_filename':$!";

		foreach my $line (<$schedule_fh>) {
			chomp($line);
			if ($line =~ /^#/) {
				print "skipping schedule line: $line\n";
			} elsif ($line =~ /^(\w+) (\d+)-(\d+)-(\d+) (\d+)-(\d+)\t(.+)$/) {
				die "unimplemented: $line";
			} elsif ($line =~ /^(\w+) (\d+)-(\d+)\t([\w. ]+)$/) {
				my ($day_of_week,$start_time,$end_time,$who) = ($1,$2,$3,$4);
				#print "line=(dow=$day_of_week,start=$start_time,end=$end_time,who=$who)\n";
				$start_time =~ s/^0+//;
				$end_time =~ s/^0+//;
				push(@{ $worked_schedule->{$day_of_week}->{$start_time} }, "$who starts shift");
				if ($start_time eq '2200') { # find tomorrow
					my $dow = 0;
					while ($day_of_week ne $days_of_weeks[$dow]) {
						$dow++;
					}
					$dow++; # and now tomorrow
					$day_of_week = $days_of_weeks[$dow];
				}
				push(@{ $worked_schedule->{$day_of_week}->{$end_time} }, "$who ends shift");
			} else {
				warn "bad parse schedule line: '$line'";
			}
		}
		close($schedule_fh) or die "failed to close schedule file '$schedule_filename':$!";
	} else {
		warn "no schedule file '$schedule_filename' found";
	}

	# loop through week
	my $date_cursor = $first_day->clone();
	for (1..7) {
		my $day_name = $date_cursor->day_name();
		my $day_of_week = $date_cursor->day_of_week();

		foreach my $swap_hour (6, 14, 22) {
			my $shift_datetime = $date_cursor->clone();
			$shift_datetime->set( minute => 0, hour => $swap_hour, second => 0 );
			my $content_line = "standard shift change for $day_name "
					. sprintf("%02d00",$swap_hour);

			if (defined $worked_schedule->{$day_name}->{"${swap_hour}00"}) {
				$content_line .= " (";
				$content_line .= join(", ", @{ $worked_schedule->{$day_name}->{"${swap_hour}00"} });
				$content_line .= ")";
			}
			push (@$timeline,{
				when => $shift_datetime,
				content_line => $content_line,
				mark_issue => 1,
				blank_before => 1,
			});
		}

		# and now for tomorrow...
		$date_cursor->add( days => 1 );
	}
}
